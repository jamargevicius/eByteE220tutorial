# eByteE220tutorial
Introduction

This is a pseudo tutorial on a very low power battery-operated remote receiver setup (a tutorial nothing like the great ones what Sara and Rui do, but since this topic has been bantered around, I know this forum is a good place for this kind of help) 

Building a remote low power Transmitter is not so hard -- the transmitter is asleep most of the time, and when programmed to wake up, it reads sensor information (for example), and sends it to a home/office-based AC powered receiver, then goes back to sleep - a very low energy situation.  

However, building a remote low power Receiver is much more complicated because, well, the receiver doesn't know when you'll talk to it, so it has to be alert all the time, draining any battery.  The good news is that there are commercially available solutions using a microcontroller that can be put to sleep, and wakes up for less than a millisecond every second (or more), listening for possible packet communication from the transmitter.  Basically, when you want to communicate with it, the home-based AC powered transmitter sends out a very long preambled packet (i.e. more than 1 second of preamble).  When the receiver wakes up for the millisecond, it senses this and then fully wakes up and "pays attention"; otherwise the receiver spends 99.9% of the time asleep in very low power mode. This method is called Wake On Receive, or WOR. 

Besides a "sleepable" microcontroller however, a low overhead radio system is required.  Expressif's ESP32 microcontroller chip can be put to sleep, but it only supports a WiFi "radio", internally ... WiFi is terribly power-hungry with a seriously complex communication protocol because it has to "fight a lot" just to communicate in a very very busy environment of cell phones, laptops, the neighbor's TV, etc, etc, etc -- "it's a jungle out there!!!" ... After many years of development, WiFi is robust, reliable, ubiquitous, but power hungry. ... So, the ESP32 chip isn't a good choice for this.  

There are at least 2 other microcontroller chips that fit the bill - they use proprietary very low overhead communication protocols and can do very low power Wake On Receive fine ... with the proper software support (and use of variants of LoRa = LongRange spread-spectrum radio protocols).  They are: Texas Instruments CC1310 microcontroller chip, and Semtech's SX1261 microcontroller chip - both have internal low-power radio support and are sleepable.  But, as with Espressif's ESP32 chip, it's hard for a DYI user to deal with the antenna, the oscillator, power supply, etc., and so, we all use the assembled ESP32 modules (e.g. ESP32-S3-WROOM) that are further built into development ("dev") kits (e.g. Dev-xxx) ... all is needed is a USB connection or power supply. 

Similarly with the TI or Semtech chips, it's really helpful to have "someone else" build a module with the antenna and other "stuff" ... and provide the software to implement the WOR protocol.  For the TI chip, the company Radio-Controlli out of Italy has attempted to build a stand-alone WOR device (but from my experience, their WOR software is very unreliable and their unit is really a demo version in need of more work). For the Semtech chip, the company eByte out of China has an antenna support module and a more robust WOR software implementation, but requires another microcontroller to "manage it" (too bad; the Semtech chip is a microcontroller, but building the software to use it is not a trivial task, nor one that eByte decided to take on).  This device and ESP32s have been used and discussed a lot by William Lucid in this RNT blog. His is a nice web server application built on top of the eByte module, but I found the project too complex to get a good understanding of the relatively simple eByte unit.  A good understanding is helpful for solving bugs and other creative uses. 

Again, the eByte module needs a microcontroller to manage it.  So, using the ESP32, or a Raspberry Pi is a necessary component.  I use ESP32s in this discussion, but have built a system with the sleep-able ESP32 on the receiver (using the necessary C++ code), and an AC driven, non sleep-able Raspberry Pi (using the friendlier python code).  The link to that system for anyone interested is given later. 

What follows is a pseudo-tutorial (ie. not a Sara/Rui top-quality tutorial) based on the eByte product.  In the end, you will have 2 units, 1 labeled the Tx, and the other the Rx, with both eBytes in WOR mode when necessary. It will use ESP32s as "managers";  only the Rx eByte and Rx ESP32 will go into sleep mode for very low power operation, while the transmitter will always be awake.  For this tutorial, both the Rx and Tx units will be AC driven, since the ESP32s will be on a "dev" board which is USB-driven (i.e. driven via an AC "wall wart").   

I provide a walk-through of setting up the 2 ESP32 dev boards each with their eByte modules, initially showing  the very simple 8 wire connections needed for each side.  The setup includes test code, called testDevices - this is developed using Visual Code Studio (using Arduino IDE and/or Espressif IDE is a future project if there is interest).  Then I go into more complicated testing programs to eventually result in a "reliable" Tx-Rx system. 

I will assume that you have downloaded all the test program folders, which are:

- testDevices
- 

